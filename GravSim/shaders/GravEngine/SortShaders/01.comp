#version 460

const uint WORKSIZE =  1024;
const uint SUBSIZE = 32;
const uint ADD_PER_THREAD = 1;
const uint SEGMENTSIZE = 256;
const uint SEGMENTBITS = 8;
const uint MOVE_PER_THREAD = 1;
const uint PROCESS_PER_THREAD = 1;
const uint CELL_COUNT = 4096;
const ivec3 GRID_DIMENSIONS = ivec3(16, 16, 16);
const vec3 DOMAIN_DIMENSIONS = vec3(10, 10, 10);
const int SEARCH_SIZE = 1;
const uint SEARCH_CELLS = 9; //pow(2*SEARCH_SIZE + 1, 3);
const float CONSTANT_G = 0.00001;
const float dt = 0.5;


struct Particle{
    vec4 pos; //mass packed as w
    vec4 vel;   //unused packed as w
    uint cell;
    uint newIndex;
};
struct UParticle{
    vec3 pos;
    vec3 vel;
    float unused;
    float mass;
    uint cell;
    uint newIndex;
};


layout (std430, binding = 2) readonly buffer SSBOInput2{
    uint oldOffsets[ ];
};
layout (std430, binding = 3) buffer SSBOInput3{
    uint deltaOffsets[ ];
};
layout (std430, binding = 4) readonly buffer PartInput{
    Particle particlesIn[ ];
};
layout (std430, binding = 5) buffer PartOutput{
    Particle particlesOut[ ];
};

layout (local_size_x = WORKSIZE) in;

void calculateCellID(in vec3 pos, out uint cellID){
    ivec3 cellPos;
    cellPos.x = int(floor(pos.x * GRID_DIMENSIONS.x / DOMAIN_DIMENSIONS.x));
    cellPos.y = int(floor(pos.y * GRID_DIMENSIONS.y / DOMAIN_DIMENSIONS.y));
    cellPos.z = int(floor(pos.z * GRID_DIMENSIONS.z / DOMAIN_DIMENSIONS.z));

    cellID = cellPos.x + cellPos.y * GRID_DIMENSIONS.x + cellPos.z * GRID_DIMENSIONS.x * GRID_DIMENSIONS.y;
}
void unpackParticle(in Particle pIn, out UParticle pOut){
    pOut.pos = pIn.pos.xyz;
    pOut.vel = pIn.vel.xyz;
    pOut.unused = pIn.pos.w;
    pOut.mass = pIn.vel.w;
    pOut.cell = pIn.cell;
    pOut.newIndex = pIn.newIndex;
}
void repackParticle(in UParticle pIn, out Particle pOut){
    pOut.pos = vec4(pIn.pos.x, pIn.pos.y, pIn.pos.z, pIn.unused);
    pOut.vel = vec4(pIn.vel.x, pIn.vel.y, pIn.vel.z, pIn.mass);
    pOut.cell = pIn.cell;
    pOut.newIndex = pIn.newIndex;
}
void getAdjacentCells(in int cID, out uint cIDs[SEARCH_CELLS]){
    //cells are ordered x y z;
    //so 1,0,0 is at 1
    //0,1,0 is at 64
    // 0, 0, 1 is at 64 * 64;
    ivec3 cellPos;
    cellPos.x = cID % GRID_DIMENSIONS.x;
    cellPos.y = ((cID - cellPos.x) / GRID_DIMENSIONS.x) % GRID_DIMENSIONS.y;
    cellPos.z = ((((cID - cellPos.x) / GRID_DIMENSIONS.x) - cellPos.y) / GRID_DIMENSIONS.y) % GRID_DIMENSIONS.z;
    uint outIndex = 0;
    for (int i = -SEARCH_SIZE; i<=SEARCH_SIZE; i++){
        for (int j = -SEARCH_SIZE; j<=SEARCH_SIZE; j++){
            for (int k = -SEARCH_SIZE; k<=SEARCH_SIZE; k++){
                ivec3 newCellPos = cellPos + ivec3(i, j, k);
                int ncID = newCellPos.x + GRID_DIMENSIONS.x * newCellPos.y + GRID_DIMENSIONS.x * GRID_DIMENSIONS.y * newCellPos.z;
                if(newCellPos.x < 0 || newCellPos.y < 0 || newCellPos.z < 0 || newCellPos.x >= GRID_DIMENSIONS.x || newCellPos.y >= GRID_DIMENSIONS.y || newCellPos.z >= GRID_DIMENSIONS.z){
                    ncID = int(CELL_COUNT);
                }
                cIDs[outIndex] = uint(ncID);
                outIndex++;
            }
        }
    }
}
void evaluateForce(in UParticle pIn1, in UParticle pIn2, out vec3 F){
    vec3 sep = pIn1.pos - pIn2.pos;
    float sep2 = dot(sep, sep);
    float sep2Inv = 1 / sep2;
    float massProd = pIn1.mass * pIn2.mass;
    F = CONSTANT_G * massProd * sep2Inv * sep;
}
void evaluateBoundaryForce(in UParticle pIn, out vec3 F){
    float xSep = (pIn.pos.x < DOMAIN_DIMENSIONS.x / 2) ? pIn.pos.x : pIn.pos.x - DOMAIN_DIMENSIONS.x;
    float ySep = (pIn.pos.y < DOMAIN_DIMENSIONS.y / 2) ? pIn.pos.y : pIn.pos.y - DOMAIN_DIMENSIONS.y;
    float zSep = (pIn.pos.z < DOMAIN_DIMENSIONS.z / 2) ? pIn.pos.z : pIn.pos.z - DOMAIN_DIMENSIONS.z;

    F = vec3(pIn.mass / xSep, pIn.mass / ySep, pIn.mass / zSep);
}





void main(){

    for (uint i =0; i < PROCESS_PER_THREAD; i++){
        uint pID = PROCESS_PER_THREAD * gl_GlobalInvocationID.x + i;
        UParticle pMain;
        unpackParticle(particlesIn[pID], pMain);
        uint cID = pMain.cell;
        uint cIDs[SEARCH_CELLS];
        getAdjacentCells(int(cID), cIDs);
        uint offsetStarts[SEARCH_CELLS];
        uint offsetEnds[SEARCH_CELLS];
        bool edgeFlag;//if on the edge check were only reading valid cells
        for(uint j = 0; j < SEARCH_CELLS; j++){
            if(cIDs[j] != CELL_COUNT){
                if(cIDs[j] == CELL_COUNT - 1){
                    offsetStarts[j] = oldOffsets[cIDs[j]];
                    offsetEnds[j] = particlesIn.length();
                }
                else {
                    offsetStarts[j] = oldOffsets[cIDs[j]];
                    offsetEnds[j] = oldOffsets[cIDs[j] + 1];
                }
            }
            else{ edgeFlag = true;}
        }
        vec3 Force;
        vec3 F;
        UParticle pAux;

        //apply particle - particle forces;
        //for non-edge cells we can skip the 2nd check;
        if (edgeFlag){
            for(uint j = 0; j < SEARCH_CELLS; j++){
                if(cIDs[j] != CELL_COUNT){
                    for(uint p2ID = offsetStarts[j]; p2ID < offsetEnds[j]; p2ID++){
                        if(p2ID != pID){
                        unpackParticle(particlesIn[p2ID], pAux);
                        evaluateForce(pMain, pAux, F);
                        Force += F;
                        }
                    }
                }
                //now apply cell repulsion
                evaluateBoundaryForce(pMain, F);
                Force += F;
            }
        }
        else {
            for(uint j = 0; j < SEARCH_CELLS; j++){
                for(uint p2ID = offsetStarts[j]; p2ID < offsetEnds[j]; p2ID++){
                    if(p2ID != pID){
                    unpackParticle(particlesIn[p2ID], pAux);
                    evaluateForce(pMain, pAux, F);
                    Force += F;
                    }
                }
            }
        }
        //now apply convert to acceleration
        vec3 acc = Force / pMain.mass;
        acc = vec3(acc.x, acc.y - 9.81, acc.z);


        UParticle npMain;
        npMain.mass = pMain.mass;
        npMain.unused = pMain.unused;
        npMain.vel = pMain.vel + acc * dt;
        //npMain.pos = pMain.pos + npMain.vel * dt;
        npMain.pos = pMain.pos;
        uint ncID;
        calculateCellID(npMain.pos, ncID);
        if(ncID >= CELL_COUNT){
            npMain.pos = vec3(5, 5, 5);
            npMain.vel = vec3(0, 0, 0);
            calculateCellID(npMain.pos, ncID);
        }

        npMain.cell = ncID;
        if (ncID != cID){
            //particle has moved cell;
            uint dOfIndAdd = uint(floor(float(ncID) / 2));
            uint dOfBitAdd = ncID % 2;
            uint dOfIndSub = uint(floor(float(cID ) / 2));
            uint dOfBitSub = cID  % 2;

            uint dOfValAdd = 1 << (8 + dOfBitAdd * SEGMENTBITS * 2);
            uint dOfValSub = 1 << (0 + dOfBitSub * SEGMENTBITS * 2);
            
            uint codedInd = 0;
            codedInd = atomicAdd(deltaOffsets[dOfIndAdd], dOfValAdd);
            atomicAdd(deltaOffsets[dOfIndSub], dOfValSub);
            uint newInd = codedInd >> (8 + dOfBitAdd * SEGMENTBITS * 2);
            newInd = newInd & (SEGMENTSIZE - 1);
            newInd++;
            npMain.newIndex = newInd;
        }
        else {
            npMain.newIndex = 0;
        }
        Particle npMain2;
        repackParticle(npMain, npMain2);
        particlesOut[pID] = npMain2;
    }
}