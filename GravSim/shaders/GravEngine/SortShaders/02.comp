#version 450

#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_ballot : enable

const uint WORKSIZE =  1024;
const uint SUBSIZE = 32;
const uint ADD_PER_THREAD = 1;
const uint SEGMENTSIZE = 256;
const uint SEGMENTBITS = 8;


//this shader performs the final reduced scan

layout(std140, binding  = 0) buffer SSBOstageInput {
    int scanIn[ ];
};

shared int subTotals[WORKSIZE / SUBSIZE];

layout(local_size_x = WORKSIZE, local_size_y = 1, local_size_z = 1) in;

void main(){
    uint gID = gl_GlobalInvocationID.x;
    uint lID = gl_LocalInvocationID.x;
    uint sID = lID >> 5;

    int threadSum = scanIn[gID];
    int subSum = subgroupExclusiveAdd(threadSum);
    int subgroupScanOut = 0;

    if ((lID & (SUBSIZE - 1)) == SUBSIZE - 1){ //select the 31 thread of the subgroup as that will have the highest subSum
        subTotals[sID] = subSum + threadSum;
        barrier();
        for (uint i = 1; i < WORKSIZE / SUBSIZE; i<=1){ //reduce upsweep
            if((sID & i) == 0){//if the selected bit for the sID is 0, break out the loop
                break;
            }
            else {
                subTotals[sID] += subTotals[sID - i]; //if selected bit = 1, then add the value of the pair who's bit is 0
                barrier();
            }
        } 
        barrier();
        //scan downsweep
        for (uint i = (WORKSIZE / SUBSIZE) - 1; i > 0; i>>=1){
            if ((sID & i) == i){
                int swapDown = subTotals[sID];
                int addDown = subTotals[sID] + subTotals[sID - i - 1];
                subTotals[sID - i - 1] = swapDown;
                subTotals[sID] = addDown;
            }
            barrier();
        }
        //now that downsweep is complete and subTotals[ ] contains a complete scan;
        //we can add that to the offsets;
        subgroupScanOut = subTotals[sID];
    }

    subgroupScanOut = subgroupBroadcast(subgroupScanOut, SUBSIZE - 1);
    subSum += subgroupScanOut;
    scanIn[gID] = subSum;
}