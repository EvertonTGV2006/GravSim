#version 460

#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_ballot : enable

const int WORKSIZE =  1024;
const int SUBSIZE = 32;
const int SEGMENTSIZE = 16384;
const uint DATA_MASK = 16383;
const int SEGMENTBITS = 16;
const int CELL_COUNT = 32768;
const ivec3 GRID_DIMENSIONS = ivec3(32, 32, 32);
const vec3 DOMAIN_DIMENSIONS = vec3(16, 16, 16);
const int SEARCH_SIZE = 1;
const uint SEARCH_CELLS = 9; //pow(2*SEARCH_SIZE + 1, 3);
const float CONSTANT_G = 0.001;
const float dt = 0.001;
const vec3 normals[3] = {vec3(1, 0, 0), vec3(0,1,0),vec3(0,0,1)};
const float normalsDots[2] = {0, 16}; 

struct Particle{
    vec4 pos; //mass packed as w
    vec4 vel;   //unused packed as w
    int cell;
    int newIndex;
};
struct UParticle{
    vec3 pos;
    vec3 vel;
    float unused;
    float mass;
    int cell;
    int newIndex;
};

layout (std430, binding = 0) buffer SSBOstageOutput{
    int wScan[ ]; //size of workgroups
};
layout (std430, binding = 1) buffer SSBOOutput{
    int offA[ ]; //size of cells
};
layout (std430, binding = 2) buffer SSBOInput2{
    int offB[ ];
};
layout (std430, binding = 3) buffer SSBOInput3{
    uint dOff[ ];
};
layout (std430, binding = 4) buffer PartInput{
    Particle pIn[ ];
};
layout (std430, binding = 5) buffer PartOutput{
    Particle pOut[ ];
};
layout (local_size_x = WORKSIZE) in;

shared int sData[WORKSIZE / SUBSIZE];

uint gID = gl_GlobalInvocationID.x;
uint lID = gl_LocalInvocationID.x;
uint wID = gl_WorkGroupID.x;
uint sID = lID >> 5;


void calculateCellID(in vec3 pos, out int cellID){
    ivec3 cellPos;
    cellPos.x = int(floor(pos.x * GRID_DIMENSIONS.x / DOMAIN_DIMENSIONS.x));
    cellPos.y = int(floor(pos.y * GRID_DIMENSIONS.y / DOMAIN_DIMENSIONS.y));
    cellPos.z = int(floor(pos.z * GRID_DIMENSIONS.z / DOMAIN_DIMENSIONS.z));

    cellID = cellPos.x + cellPos.y * GRID_DIMENSIONS.x + cellPos.z * GRID_DIMENSIONS.x * GRID_DIMENSIONS.y;
}
void unpackParticle(in Particle pIn, out UParticle pOut){
    pOut.pos = pIn.pos.xyz;
    pOut.vel = pIn.vel.xyz;
    pOut.unused = pIn.pos.w;
    pOut.mass = pIn.vel.w;
    pOut.cell = pIn.cell;
    pOut.newIndex = pIn.newIndex;
}
void repackParticle(in UParticle pIn, out Particle pOut){
    pOut.pos = vec4(pIn.pos.x, pIn.pos.y, pIn.pos.z, pIn.unused);
    pOut.vel = vec4(pIn.vel.x, pIn.vel.y, pIn.vel.z, pIn.mass);
    pOut.cell = pIn.cell;
    pOut.newIndex = pIn.newIndex;
}

void checkLegalPos(in vec3 pos, out bool V){
    V= false;
    if(pos.x < 0 || pos.y<0|| pos.z <0||pos.x >= DOMAIN_DIMENSIONS.x || pos.y >= DOMAIN_DIMENSIONS.y || pos.z >= DOMAIN_DIMENSIONS.z){
        V = true;
    }
}
void checkLegalCell(in ivec3 pos, out bool V){
    V= false;
    if(pos.x < 0 || pos.y<0|| pos.z <0||pos.x >= GRID_DIMENSIONS.x || pos.y >= GRID_DIMENSIONS.y || pos.z >= GRID_DIMENSIONS.z){
        V = true;
    }
}
void getCellPos(in int cID, out ivec3 cellPos){
    cellPos.x = cID % GRID_DIMENSIONS.x;
    cellPos.y = ((cID - cellPos.x) / GRID_DIMENSIONS.x) % GRID_DIMENSIONS.y;
    cellPos.z = ((((cID - cellPos.x) / GRID_DIMENSIONS.x) - cellPos.y) / GRID_DIMENSIONS.y) % GRID_DIMENSIONS.z;
}
void getCellOrigin(in ivec3 cellPos, out vec3 cellOrigin){
    cellOrigin.x = (DOMAIN_DIMENSIONS.x / GRID_DIMENSIONS.x) * cellPos.x;
    cellOrigin.y = (DOMAIN_DIMENSIONS.y / GRID_DIMENSIONS.y) * cellPos.y;
    cellOrigin.z = (DOMAIN_DIMENSIONS.z / GRID_DIMENSIONS.z) * cellPos.z;
}
void getAdjacentCells(in int cID, out ivec3 cIDs[SEARCH_CELLS]){
    //cells are ordered x y z;
    //so 1,0,0 is at 1
    //0,1,0 is at 64
    // 0, 0, 1 is at 64 * 64;
    ivec3 cellPos;
    getCellPos(cID, cellPos);
    int outIndex = 0;
    bool boundCheck = false;
    for (int i = -SEARCH_SIZE; i<=SEARCH_SIZE; i++){
        for (int j = -SEARCH_SIZE; j<=SEARCH_SIZE; j++){
            for (int k = -SEARCH_SIZE; k<=SEARCH_SIZE; k++){
                ivec3 newCellPos = cellPos + ivec3(i, j, k);
                cIDs[outIndex] = newCellPos;
                outIndex++;
            }
        }
    }
}
void evaulateParticleForce(in UParticle p1, in UParticle p2, out vec3 F){
    vec3 sep = p1.pos - p2.pos;
    float sep2 = dot(sep, sep);
    float sep2Inv;
    float massProd;

    float scale = 0.00001;
    const float a = 1;
    const float b = 2;
    const float c = -3;
    const float d = 0.3;
    const float zeroPos = 0.01;
    //so = 0 when a * 2 ** b(x-f) = c * 2 ** d(x-f);
    //so b(x-f) / d(x-f) = log 2 c / a;
    // x-f = d/b * log2 c/a;
    // f = d/b * log2 c/a + zeroPos
    float f = (d / b) * (log(-c/a)/log(2)) + zeroPos;

    if(sep2 != 0){
        sep2Inv = 1 / sep2;
        massProd = p1.mass * p2.mass;
        //F = CONSTANT_G * massProd * sep2Inv * sep;
        F = (a * pow(2, -b * (sep2 - f)) + c * pow(2, -d * (sep2 - f))) * sep * scale;

    }
    else{
        F = vec3(0,0,0);
    }
}
void evaluateCellForces(in UParticle p1, in ivec3 c2Pos, out vec3 F){
    F = vec3(0, 0, 0);
    vec3 Ft;
    ivec3 c1Pos;
    vec3 c1Origin;
    vec3 c2Origin;
    vec3 accelDir;
    vec3 p1c2Pos;
    float fMag;
    bool flag = false;
    int cID;
    int offsetStart;
    int offsetEnd;
    Particle cp2;
    UParticle p2;


    checkLegalCell(c2Pos, flag);
    
    if (flag){
        getCellPos(p1.cell, c1Pos);
        getCellOrigin(c1Pos, c1Origin);
        getCellOrigin(c2Pos, c2Origin);
        accelDir = c1Pos - c2Pos;
        if(dot(accelDir, accelDir) == 0){
            F = vec3(0, 0, 0);
        }
        else {
            p1c2Pos = p1.pos - c2Pos;
            fMag = dot(p1c2Pos, accelDir) / dot (accelDir, accelDir);
            if (fMag == 0){
                fMag = 1;
            }
        
            fMag = 1 / fMag;

        
            fMag = fMag * p1.mass * 0.000001;

            F = fMag * accelDir;
        }
    }
    else {
        cID = c2Pos.x + c2Pos.y * GRID_DIMENSIONS.x + c2Pos.z * GRID_DIMENSIONS.x * GRID_DIMENSIONS.y;
        offsetStart = offA[cID];
        offsetEnd = (cID > offA.length()) ? offA.length() : offA[cID + 1];
        for (int pID = offsetStart; pID < offsetEnd; pID++){
            cp2 = pIn[pID];
            unpackParticle(cp2, p2);
            evaulateParticleForce(p1, p2, Ft);
            F += Ft;
        }

    }
}

void moveParticle(in UParticle p1, in vec3 F, out UParticle p2){
    p1.mass = (p1.mass == 0)? 1 : p1.mass;
    vec3 a = F / p1.mass;
    a.y = a.y - 9.81;
    p2 = p1;
    p2.vel = p1.vel + a * dt;
    p2.pos = p1.pos + p2.vel * dt;

    const uint subData = 1 << SEGMENTBITS;
    const uint addData = 1;
    uint addResult = 0;
    uint subResult = 0;

    bool legalPos;
    checkLegalPos(p2.pos, legalPos);
    ivec3 newPos;
    vec3 newPos2;
    //legalPos = false;

    if (legalPos){
        getCellPos(int(lID), newPos);
        getCellOrigin(newPos, newPos2);
        p2.pos = vec3(1,1,1);//newPos2;// + vec3(float(lID)/2000,float(lID)/2000,float(lID)/2000);
        p2.vel = vec3(0,0,0);//vec3(0, lID/2000, 0.06);
        //if pos is illegal
    }
    calculateCellID(p2.pos, p2.cell);
    if (p2.cell != p1.cell){
        addResult = atomicAdd(dOff[p2.cell], addData);
        subResult = atomicAdd(dOff[p1.cell], subData);
        p2.newIndex = int(addResult & DATA_MASK) + 1;
    }
    else{
        p2.newIndex = 0;
    }


}



void main(){
    //particle stage
    Particle pT = pIn[gID];
    UParticle pMain;
    unpackParticle(pT, pMain);
    int ocID = 0;
    calculateCellID(pMain.pos, ocID);
    pMain.cell = ocID;
    ivec3 cCellPos[SEARCH_CELLS];
    getAdjacentCells(ocID, cCellPos);
    vec3 F = vec3(0, 0, 0);
    vec3 Ft = F;
    for (int i = 0; i < SEARCH_CELLS; i++){
        evaluateCellForces(pMain, cCellPos[i], Ft);
        F += Ft;
    }
    float sep;
    for (int i = 0; i < 3; i++){
        for (int j = 0; j < 2; j++){
            sep = normalsDots[j] - dot(pMain.pos, normals[i]);
            sep = (sep == 0) ? 0.000001 : sep;
            sep = (sep < 0) ? -1 / pow(-sep, 3) : 1 / pow(sep, 3);
            F += -sep * normals[i] * 10 * pMain.mass;
        }
    }
    Ft = -0.0000001 * pMain.vel;
    F += Ft;
    UParticle pUpd;
    moveParticle(pMain, F, pUpd);
    repackParticle(pUpd, pT);
    pOut[gID] = pT;
}