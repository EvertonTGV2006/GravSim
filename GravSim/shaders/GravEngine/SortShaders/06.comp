#version 460

const int WORKSIZE =  1024;
const int SUBSIZE = 32;
const int SEGMENTSIZE = 16384;
const uint DATA_MASK = 16383;
const int SEGMENTBITS = 16;
const int CELL_COUNT = 4096;
const ivec3 GRID_DIMENSIONS = ivec3(16, 16, 16);
const vec3 DOMAIN_DIMENSIONS = vec3(10, 10, 10);
const int SEARCH_SIZE = 1;
const uint SEARCH_CELLS = 9; //pow(2*SEARCH_SIZE + 1, 3);
const float CONSTANT_G = 0.00001;
const float dt = 0.5;

struct Particle{
    vec4 pos; //mass packed as w
    vec4 vel;   //unused packed as w
    int cell;
    int newIndex;
};
struct UParticle{
    vec3 pos;
    vec3 vel;
    float unused;
    float mass;
    int cell;
    int newIndex;
};

layout (std430, binding = 0) buffer SSBOstageOutput{
    int wScan[ ]; //size of workgroups
};
layout (std430, binding = 1) buffer SSBOOutput{
    int offA[ ]; //size of cells
};
layout (std430, binding = 2) buffer SSBOInput2{
    int offB[ ];
};
layout (std430, binding = 3) buffer SSBOInput3{
    uint dOff[ ];
};
layout (std430, binding = 4) buffer PartInput{
    Particle pIn[ ];
};
layout (std430, binding = 5) buffer PartOutput{
    Particle pOut[ ];
};
layout (local_size_x = WORKSIZE) in;

shared int sData[WORKSIZE / SUBSIZE];

uint gID = gl_GlobalInvocationID.x;
uint lID = gl_LocalInvocationID.x;
uint wID = gl_WorkGroupID.x;
uint sID = gID >> 5;


void calculateCellID(in vec3 pos, out int cellID){
    ivec3 cellPos;
    cellPos.x = int(floor(pos.x * GRID_DIMENSIONS.x / DOMAIN_DIMENSIONS.x));
    cellPos.y = int(floor(pos.y * GRID_DIMENSIONS.y / DOMAIN_DIMENSIONS.y));
    cellPos.z = int(floor(pos.z * GRID_DIMENSIONS.z / DOMAIN_DIMENSIONS.z));

    cellID = cellPos.x + cellPos.y * GRID_DIMENSIONS.x + cellPos.z * GRID_DIMENSIONS.x * GRID_DIMENSIONS.y;
}
void unpackParticle(in Particle pIn, out UParticle pOut){
    pOut.pos = pIn.pos.xyz;
    pOut.vel = pIn.vel.xyz;
    pOut.unused = pIn.pos.w;
    pOut.mass = pIn.vel.w;
    pOut.cell = pIn.cell;
    pOut.newIndex = pIn.newIndex;
}
void repackParticle(in UParticle pIn, out Particle pOut){
    pOut.pos = vec4(pIn.pos.x, pIn.pos.y, pIn.pos.z, pIn.unused);
    pOut.vel = vec4(pIn.vel.x, pIn.vel.y, pIn.vel.z, pIn.mass);
    pOut.cell = pIn.cell;
    pOut.newIndex = pIn.newIndex;
}

void checkLegalPos(in vec3 pos, out bool V){
    V= false;
    if(pos.x < 0 || pos.y<0|| pos.z <0||pos.x >= DOMAIN_DIMENSIONS.x || pos.y >= DOMAIN_DIMENSIONS.y || pos.z >= DOMAIN_DIMENSIONS.z){
        V = true;
    }
}
void checkLegalCell(in ivec3 pos, out bool V){
    V= false;
    if(pos.x < 0 || pos.y<0|| pos.z <0||pos.x >= GRID_DIMENSIONS.x || pos.y >= GRID_DIMENSIONS.y || pos.z >= GRID_DIMENSIONS.z){
        V = true;
    }
}
void getCellPos(in int cID, out ivec3 cellPos){
    cellPos.x = cID % GRID_DIMENSIONS.x;
    cellPos.y = ((cID - cellPos.x) / GRID_DIMENSIONS.x) % GRID_DIMENSIONS.y;
    cellPos.z = ((((cID - cellPos.x) / GRID_DIMENSIONS.x) - cellPos.y) / GRID_DIMENSIONS.y) % GRID_DIMENSIONS.z;
}
void getCellOrigin(in ivec3 cellPos, out vec3 cellOrigin){
    cellOrigin.x = (DOMAIN_DIMENSIONS.x / GRID_DIMENSIONS.x) * cellPos.x;
    cellOrigin.y = (DOMAIN_DIMENSIONS.y / GRID_DIMENSIONS.y) * cellPos.y;
    cellOrigin.z = (DOMAIN_DIMENSIONS.z / GRID_DIMENSIONS.z) * cellPos.z;
}
void getAdjacentCells(in int cID, out ivec3 cIDs[SEARCH_CELLS]){
    //cells are ordered x y z;
    //so 1,0,0 is at 1
    //0,1,0 is at 64
    // 0, 0, 1 is at 64 * 64;
    ivec3 cellPos;
    getCellPos(cID, cellPos);
    int outIndex = 0;
    bool boundCheck = false;
    for (int i = -SEARCH_SIZE; i<=SEARCH_SIZE; i++){
        for (int j = -SEARCH_SIZE; j<=SEARCH_SIZE; j++){
            for (int k = -SEARCH_SIZE; k<=SEARCH_SIZE; k++){
                ivec3 newCellPos = cellPos + ivec3(i, j, k);
                checkLegalCell(newCellPos, boundCheck);
                cIDs[outIndex] = newCellPos;
                outIndex++;
            }
        }
    }
}
void evaulateParticleForce(in UParticle p1, in UParticle p2, out vec3 F){
    vec3 sep = p1.pos - p2.pos;
    float sep2 = dot(sep, sep);
    float sep2Inv = 1 / sep2;
    float massProd = p1.mass * p2.mass;
    F = CONSTANT_G * massProd * sep2Inv * sep;
}
void evaluateCellForces(in UParticle p1, in ivec3 c2Pos, out vec3 F){
    F = vec3(0, 0, 0);
    vec3 Ft;
    ivec3 c1Pos;
    vec3 c1Origin;
    vec3 c2Origin;
    vec3 accelDir;
    vec3 p1c2Pos;
    float fMag;
    bool flag = false;
    int cID;
    int offsetStart;
    int offsetEnd;
    Particle cp2;
    UParticle p2;


    checkLegalCell(c2Pos, flag);
    
    if (flag){
        getCellPos(p1.cell, c1Pos);
        getCellOrigin(c1Pos, c1Origin);
        getCellOrigin(c2Pos, c2Origin);
        accelDir = c1Pos - c2Pos;
        p1c2Pos = p1.pos - c2Pos;
        fMag = dot(p1c2Pos, accelDir) / dot (accelDir, accelDir);
        fMag = 1 / fMag;
        fMag = fMag * p1.mass * 0.1;

        F = fMag * accelDir;
    }
    else {
        cID = c2Pos.x + c2Pos.y * GRID_DIMENSIONS.x + c2Pos.z * GRID_DIMENSIONS.x * GRID_DIMENSIONS.y;
        offsetStart = offA[cID];
        offsetEnd = (cID > offA.length()) ? offA.length() : offA[cID + 1];
        for (int pID = offsetStart; pID < offsetEnd; pID++){
            cp2 = pIn[pID];
            unpackParticle(cp2, p2);
            evaulateParticleForce(p1, p2, Ft);
            F += Ft;
        }
    }
}

void moveParticle(in UParticle p1, in vec3 F, out UParticle p2;){
    vec3 a = F / p1.mass;
    p2 = p1;
    p2.vel = p1.vel + a * dt;
    p2.pos = p1.pos + p2.vel * dt;

    const uint subData = 1 << SEGMENTBITS;
    const uint addData = 1;
    uint addResult = ;

    bool legalPos;
    checkLegalPos(p2.pos, legalPos);

    if (legalPos){
        //if pos is illegal
    }
    else {
        calculateCellID(p2.pos, p2.cell);
        if (p2.cell != p1.cell){
            addResult = atomicAdd(dOff[p2.cell], addData);
            atomicAdd(dOff[p1.cell], subData);
            p2.newIndex = int(addResult & DATA_MASK)
        }
    }

}
void parrallelScanUpA(in int vI, out int vO, bool mode){
    int sv = subgroupExclusiveAdd(vI);
    if (lID & (SUBSIZE - 1) == SUBSIZE - 1){
        sData[sID] = sv + vI;
    }
    barrier();
    int bVal = 0;
    int sMask;
    for (int i = 5; i<= 10; i++){
        sMask = (1 << i) - 1;
        if ((lID & sMask) > 0 && bVal = 0){
            sData[sID] = sData[sID] + sData[sID + 1 - sMask];
        }
        else{
            bVal = i;
        }
        barrier();
    }
    if (lID == WORKSIZE - 1){
        if(mode){
            wScan[wID] = sData[sID];
        }
        sData[sID] = 0;
    }
    barrier();
    int sd;
    int ad;
    for (int i = 10; i>=5; i--){
        sMask = (1 << i) - 1;
        if ((lID & sMask) > 0 && bVal < i){
            sd = sData[sID];
            ad = sData[sID] + sData[sID + 1 - sMask];
            sData[sID] = ad;
            sData[sID + 1 - sMask] = sd;
        }
        barrier();
    }
    int sr = 0;
    if (lID & (SUBSIZE - 1) == SUBSIZE - 1){
        sr = sData[sID];
    }
    sr = subgroupBroadcast(sr, SUBSIZE - 1);
    vO = sv + sr;
}


void stage01(){
    //particle stage
    Particle pT = pIn[gID];
    UParticle pMain;
    unpackParticle(pT, pMain);
    int ocID = 0;
    calculateCellID(pMain.pos, ocID);
    ivec3 cCellPos[SEARCH_CELLS];
    getAdjacentCells(ocID, cCellPos);
    vec3 F = vec3(0, 0, 0);
    vec3 Ft = F;
    for (int i = 0; i < SEARCH_CELLS; i++){
        evaluateCellForces(pMain, cCellPos[i], Ft);
        F += Ft;
    }
    UParticle pUpd;
    moveParticle(pMain, F, pUpd);
    repackParticle(pUpd, pT);
    pOut[gID] = pT;
}