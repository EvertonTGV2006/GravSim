#version 460

#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_ballot : enable

const uint WORKSIZE =  1024;
const uint SUBSIZE = 32;
const uint ADD_PER_THREAD = 1;
const uint SEGMENTSIZE = 256;
const uint SEGMENTBITS = 8;
const uint CELL_COUNT = 4096;

layout(std430, binding  = 0) buffer SSBOstageInput {
    int scanIn[ ];
};

shared int subTotals[WORKSIZE / SUBSIZE];

layout(local_size_x = WORKSIZE, local_size_y = 1, local_size_z = 1) in;

void main(){
    uint gID = gl_GlobalInvocationID.x;
    uint lID = gl_LocalInvocationID.x;
    uint sID = lID >> 5;

    int threadSum = 0;
    if (gID < (CELL_COUNT / WORKSIZE)){
        threadSum = scanIn[gID];
    }
    int subSum = subgroupExclusiveAdd(threadSum);
    int subgroupScanOut = 0;

    if ((lID & (SUBSIZE - 1)) == SUBSIZE - 1){ //select the 31 thread of the subgroup as that will have the highest subSum
        subTotals[sID] = subSum + threadSum;
    }

    barrier();
    uint breakStage = 0;
    bool flag = false;
    for (uint i = 1; i < WORKSIZE / SUBSIZE; i=i<<1){ //reduce upsweep
        if(((sID & i) == 0 )|| (flag == true)){//if the selected bit for the sID is 0, stop execution in subsequent branches, cant use break becuase of barrier();
            flag = true;
        }
        else {
            subTotals[sID] += subTotals[sID - i]; //if selected bit = 1, then add the value of the pair who's bit is 0
            breakStage = i;
        }
        barrier();
    } 
    //write out total
    if (lID == WORKSIZE - 1){
        subTotals[sID] = 0;
    }
    barrier();
    for (uint i = WORKSIZE / SUBSIZE - 1; i > 0; i = i>>1){
        if (i<=breakStage * 2){
            uint ri = sID;
            uint ai = sID - (i>>1) - 1;
            int sd = subTotals[ri];
            int ad = subTotals[ri] + subTotals[ai];
            subTotals[ri] = ad;
            subTotals[ai] = sd;
        }
        barrier();
    }
    if ((lID & (SUBSIZE - 1)) == SUBSIZE - 1){
        subgroupScanOut = subTotals[sID];
    }
    subgroupScanOut = subgroupBroadcast(subgroupScanOut, SUBSIZE - 1);
    subSum += subgroupScanOut;
    if (gID < (CELL_COUNT / WORKSIZE)){
        scanIn[gID] = subSum;
    }
    
}